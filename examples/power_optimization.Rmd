
---
title: "Optimizing sampling schedules with PowerCHORD"
output: html_document
---

## Who is this for?
This guide is for bioinformatics and experimental design practitioners who need
to choose sampling times under real-world constraints (e.g., clinic
availability, dark periods) while maintaining power to detect circadian rhythms.

## Optimization methods available
PowerCHORD includes three optimization methods:
- differential evolution (heuristic, flexible)
- exhaustive search (exact over a grid, used here)
- semidefinite programming (convex relaxation for certain formulations)

In this notebook we demonstrate an exhaustive search in R.

Note: We use a coarse time grid `(Nfine=24)` for speed. For research
applications, consider `(Nfine=48)` (half-hour resolution) or finer if
computation permits.
```{r}
library(PowerCHORD)
set.seed(123)
```

# Basic usage

## Example: schedule with a rest window

The `exhaustiveSearch` function enumerates designs on a discrete grid and
filters those satisfying constraints. Typical constraints include rest 
windows (no sampling allowed) and total number of samples `N`.

Schedule 8 measurements in a circadian study such that:
- measurements lie on an hourly grid
- there is a 12-hour window during which no measurements are scheduled

```{r}
Nfine    = 24 # 1-hr intervals on [0,1], equivalent to hourly resolution of a circadian study
N        = 8  # number of samples

# blackout window over half the study
wlen     = 12  # window length in grid units (hours here)
wdensity = 0   # number of samples allowed inside the window

# if using larger Nfine, this may take minutes
bvec = exhaustiveSearch(N=N,
                        Nfine=Nfine, wlen=wlen, wdensity=wdensity,
                        returnType='optimal')

# convert to scaled times
tau = c(1:Nfine)/Nfine - 1/Nfine
meas_times = tau[bvec>0]

# worst-case power across acrophases
evalWorstPower(meas_times, Amp=2, freq=1) 
```

Interpretation: The returned binary vector `bvec` indicates selected grid
locations. Converting to `meas_times` yields the actual schedule for downstream
power evaluation or simulation.


## Return all constrained designs
Return all designs satisfying the constraints (rather than just the optimal
one). This is useful if you want to compare designs on additional criteria
(e.g., logistics) after filtering by power.
```{r}
Nfine    = 24 # corresponds to hour intervals in circadian study
N        = 8  # number of measurements to collect

# no measurements for half the study 
wlen     = 12  # length of window
wdensity = 0   # prescribed number of measurements during window
df = exhaustiveSearch(N=N,
                 Nfine=Nfine,wlen=wlen,wdensity=wdensity,
                 returnType='all')
nrow(df) # number of constrained solutions
head(df)
```

## Remove window constraint
To see the entire design database, turn off the window constraint:
```{r}
Nfine    = 24 # corresponds to hour intervals in circadian study
N        = 8  # number of measurements to collect

# no measurements for half the study 
wlen     = 1  # length of window, equivalent to removing constraint
wdensity = 1  # prescribed number of measurements during window
df = exhaustiveSearch(N=N,
                 Nfine=Nfine,wlen=wlen,wdensity=wdensity,
                 returnType='all')
nrow(df) # should be 30667 
```

Optional: if you want to count the number of designs and check that it matches
the result of exhaustive search
```{r}
#install.packages("numbers")
#require(numbers)
Nfine = 24
N     = 8
jvals = numbers::divisors(numbers::GCD(N,Nfine))
count=0
for (jj in jvals){
  count=count+numbers::eulersPhi(jj)*choose(Nfine/jj,N/jj)
}
count/Nfine
```

## Practical guidance
- Choose `Nfine` to match your feasible resolution (e.g., 30 min â‡’ `Nfine=48`). Larger `Nfine` grows the search space.
- Use `returnType='all'` to shortlist designs by power, then pick the most practical schedule.
- Evaluate both exact power at nominal acrophases and worst-case power when acrophase is uncertain.

## Next steps
- For study planning with sample size calculations and Nyquist considerations, see `power_analysis.Rmd`.